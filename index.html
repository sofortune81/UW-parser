<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Processor with Discord Alerts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 20px;
        }
        #dropZone:hover {
            border-color: #999;
        }
        #threshold {
            margin-bottom: 10px;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        #status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        h2 {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <h1>CSV Data Processor with Discord Alerts</h1>

    <div id="dropZone">
        Drag and drop a CSV file here or click to select
    </div>

    <div>
        <label for="threshold">Premium/MC * 1,000,000 Threshold (minimum 1):</label>
        <input type="number" id="threshold" value="1" min="1" step="0.01">
    </div>

    <button onclick="processData()">Process Data</button>

    <div id="status"></div>

    <h2>All Data</h2>
    <table id="allDataTable" style="display: none;">
        <thead>
            <tr>
                <th>Underlying Symbol</th>
                <th>Type</th>
                <th>Premium</th>
                <th>Market Cap</th>
                <th>Premium/MC * 1,000,000</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h2>Filtered Data (Above Threshold)</h2>
    <table id="resultsTable" style="display: none;">
        <thead>
            <tr>
                <th>Underlying Symbol</th>
                <th>Type</th>
                <th>Premium</th>
                <th>Market Cap</th>
                <th>Premium/MC * 1,000,000</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        const WEBHOOK_URL = 'YOUR_DISCORD_WEBHOOK_URL_HERE'; // Replace with your actual webhook URL
        let csvData = [];

        const dropZone = document.getElementById('dropZone');
        const status = document.getElementById('status');

        dropZone.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    parseCSV(file);
                }
            };
            input.click();
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#999';
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = '#ccc';
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#ccc';
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.csv')) {
                parseCSV(file);
            }
        });

        function parseCSV(file) {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    csvData = results.data;
                    console.log('Parsed CSV Headers:', results.meta.fields);
                    console.log('Parsed CSV Data:', csvData);
                    const requiredColumns = ['underlying_symbol', 'premium', 'marketcap'];
                    const missingColumns = requiredColumns.filter(col => !results.meta.fields.includes(col));
                    if (missingColumns.length > 0) {
                        status.innerHTML = `<div class="error">Missing required columns in CSV: ${missingColumns.join(', ')}</div>`;
                    } else {
                        status.innerHTML = `<div class="success">CSV parsed successfully! ${csvData.length} rows loaded.</div>`;
                    }
                },
                error: function(error) {
                    status.innerHTML = `<div class="error">Error parsing CSV: ${error}</div>`;
                }
            });
        }

        function processData() {
            if (csvData.length === 0) {
                status.innerHTML = `<div class="error">Please load a CSV file first.</div>`;
                return;
            }

            const threshold = parseFloat(document.getElementById('threshold').value) || 1;

            // Compute Premium/MC * 1M for each row
            const allData = csvData.map(row => {
                const premium = parseFloat(row['premium']) || 0;
                const marketCap = parseFloat(row['marketcap']) || 0;
                const ratio = marketCap > 0 ? (premium / marketCap) * 1000000 : 0;
                console.log(`Calculating for ${row.underlying_symbol || 'Unknown'}: Premium = ${premium}, Market Cap = ${marketCap}, Ratio = ${ratio}`);
                return {
                    ...row,
                    Ratio: ratio
                };
            });

            // Filter data based on threshold
            const filteredData = allData.filter(row => row.Ratio >= threshold);

            console.log('All Data:', allData);
            console.log('Filtered Data:', filteredData);

            // Display all data table
            const allTable = document.getElementById('allDataTable');
            const allTbody = allTable.querySelector('tbody');
            allTbody.innerHTML = '';
            allData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.underlying_symbol || ''}</td>
                    <td>${row.type || ''}</td>
                    <td>${row.premium || ''}</td>
                    <td>${row.marketcap || ''}</td>
                    <td>${row.Ratio.toFixed(2)}</td>
                `;
                allTbody.appendChild(tr);
            });
            allTable.style.display = allData.length > 0 ? 'table' : 'none';

            // Display filtered data table
            const table = document.getElementById('resultsTable');
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = '';
            filteredData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.underlying_symbol || ''}</td>
                    <td>${row.type || ''}</td>
                    <td>${row.premium || ''}</td>
                    <td>${row.marketcap || ''}</td>
                    <td>${row.Ratio.toFixed(2)}</td>
                `;
                tbody.appendChild(tr);
            });
            table.style.display = filteredData.length > 0 ? 'table' : 'none';

            status.innerHTML = `<div class="success">Processed ${allData.length} rows, ${filteredData.length} above threshold.</div>`;

            if (filteredData.length > 0) {
                sendDiscordAlerts(filteredData);
            } else {
                status.innerHTML += `<div class="error">No data above threshold to send to Discord.</div>`;
            }
        }

        function sendDiscordAlerts(data) {
            if (!WEBHOOK_URL || WEBHOOK_URL === 'YOUR_DISCORD_WEBHOOK_URL_HERE') {
                status.innerHTML += `<div class="error">Invalid or missing Discord webhook URL.</div>`;
                return;
            }

            const now = new Date();
            const date = now.toISOString().split('T')[0];
            const time = now.toTimeString().split(' ')[0];

            // Group data by underlying_symbol (ticker)
            const grouped = {};
            data.forEach(row => {
                const symbol = row.underlying_symbol || 'Unknown';
                if (!grouped[symbol]) {
                    grouped[symbol] = [];
                }
                grouped[symbol].push(row);
            });

            console.log('Grouped Data for Discord:', grouped);

            Object.entries(grouped).forEach(([ticker, rows]) => {
                // Prepare fields for each row
                const rowFields = rows.map(row => {
                    const fields = {
                        'Premium/mc ratio': row.Ratio.toFixed(2),
                        date: date,
                        time: time,
                        underlying_symbol: row.underlying_symbol || '',
                        side: row.side || '',
                        strike: row.strike || '',
                        type: row.type || '',
                        expiry: row.expiry || '',
                        DTE: row.DTE || '',
                        option_chain_id: row.option_chain_id || '',
                        marketcap: row.marketcap || '',
                        premium: row.premium || '',
                        BID: row.BID || '',
                        ASK: row.ASK || '',
                        price: row.price || '',
                        underlying_price: row.underlying_price || '',
                        size: row.size || '',
                        volume: row.volume || ''
                    };
                    return Object.entries(fields)
                        .map(([k, v]) => `**${k}:** ${v}`)
                        .join('\n');
                });

                // Build message
                let message = `**Ticker: ${ticker}**\n\n`;
                rowFields.forEach(fields => {
                    message += `${fields}\n\n`;
                });

                // Split if exceeds 1800 chars
                const messages = [];
                const lines = message.split('\n');
                let currentMsg = `**Ticker: ${ticker}**\n\n`;
                let currentLength = currentMsg.length;

                for (const line of lines) {
                    if (line.startsWith('**Ticker:')) continue;
                    const testLength = currentLength + line.length + 1;
                    if (testLength > 1800 && currentMsg !== `**Ticker: ${ticker}**\n\n`) {
                        messages.push(currentMsg.trim());
                        currentMsg = `**Ticker: ${ticker} (cont.)**\n\n${line}\n`;
                        currentLength = currentMsg.length;
                    } else {
                        currentMsg += `${line}\n`;
                        currentLength = currentMsg.length;
                    }
                }
                if (currentMsg.trim()) {
                    messages.push(currentMsg.trim());
                }

                console.log(`Messages for ${ticker}:`, messages);

                // Send each message
                messages.forEach((msg, index) => {
                    setTimeout(() => {
                        fetch(WEBHOOK_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                content: msg
                            })
                        }).then(response => {
                            if (response.ok) {
                                console.log(`Alert sent for ${ticker} part ${index + 1}`);
                                status.innerHTML += `<div class="success">Alert sent for ${ticker} part ${index + 1}</div>`;
                            } else {
                                console.error('Failed to send alert:', response.statusText);
                                status.innerHTML += `<div class="error">Failed to send alert for ${ticker} part ${index + 1}: ${response.statusText}</div>`;
                            }
                        }).catch(error => {
                            console.error('Error:', error);
                            status.innerHTML += `<div class="error">Error sending alert for ${ticker}: ${error.message}</div>`;
                        });
                    }, index * 2000);
                });
            });
        }
    </script>
</body>
</html>