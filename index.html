<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Processor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #dropZone { border: 2px dashed #ccc; padding: 20px; text-align: center; cursor: pointer; }
        #dropZone.dragover { background-color: #e0e0e0; }
        #mcRatioInput { margin: 10px 0; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        button { padding: 10px; margin: 10px 0; }
    </style>
</head>
<body>
    <div id="dropZone">Drag and drop a CSV file here or click to select</div>
    <input type="file" id="fileInput" accept=".csv" style="display: none;">
    <div>
        <label for="mcRatioInput">Premium/MC * 1,000,000 Threshold (minimum 1):</label>
        <input type="number" id="mcRatioInput" value="100" min="1">
        <button onclick="processData()">Process Data</button>
    </div>
    <table id="resultTable">
        <thead>
            <tr>
                <th>Symbol</th>
                <th>Type</th>
                <th>Total Premium</th>
                <th>Market Cap</th>
                <th>Premium/MC * 1,000,000</th>
            </tr>
        </thead>
        <tbody id="resultBody"></tbody>
    </table>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const resultBody = document.getElementById('resultBody');

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length) fileInput.files = files;
            processFile(files[0]);
        });
        fileInput.addEventListener('change', () => processFile(fileInput.files[0]));

        function processFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvData = e.target.result;
                parseCSV(csvData);
            };
            reader.readAsText(file);
        }

        function parseCSV(csvData) {
            const rows = csvData.split('\n').map(row => row.split(',').map(cell => cell.trim()));
            const headers = rows[0];
            const requiredColumns = ['date', 'time', 'underlying_symbol', 'side', 'strike', 'type', 'expiry', 'bid', 'ask', 'underlying_price', 'marketcap'];
            const columnIndices = {};
            requiredColumns.forEach(col => {
                const index = headers.indexOf(col);
                if (index === -1) {
                    alert(`Missing required column: ${col}`);
                    return;
                }
                columnIndices[col] = index;
            });
            if (Object.keys(columnIndices).length !== requiredColumns.length) return;

            const aggregates = {};
            for (let i = 1; i < rows.length; i++) {
                const row = rows[i];
                if (row.length < headers.length) continue;
                const symbol = row[columnIndices.underlying_symbol];
                const type = row[columnIndices.type];
                const side = row[columnIndices.side];
                const premium = parseFloat(row[columnIndices.ask]) || parseFloat(row[columnIndices.bid]) || 0;
                const marketCap = parseFloat(row[columnIndices.marketcap]) || 0;
                if (!symbol || !type || marketCap <= 0) continue;
                if (!['ASK', 'BID'].includes(side)) {
                    console.warn(`Invalid side value "${side}" in row ${i + 1}`);
                    continue;
                }
                const key = `${symbol}_${type}`;
                if (!aggregates[key]) {
                    aggregates[key] = {
                        symbol,
                        type,
                        totalPremium: 0,
                        marketCap,
                        rows: []
                    };
                }
                aggregates[key].totalPremium += (side === 'ASK' ? premium : -premium);
                aggregates[key].rows.push({
                    date: row[columnIndices.date],
                    time: row[columnIndices.time],
                    symbol,
                    side,
                    strike: row[columnIndices.strike],
                    type,
                    expiry: row[columnIndices.expiry],
                    bid: row[columnIndices.bid],
                    ask: row[columnIndices.ask],
                    spot: row[columnIndices.underlying_price]
                });
            }
            displayResults(aggregates);
        }

        function displayResults(aggregates) {
            resultBody.innerHTML = '';
            const mcRatioThreshold = Math.max(1, parseFloat(document.getElementById('mcRatioInput').value) || 100);
            Object.values(aggregates).forEach(agg => {
                if (agg.totalPremium <= 0) return;
                const ratio = (agg.totalPremium / agg.marketCap) * 1000000;
                if (ratio >= mcRatioThreshold) {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${agg.symbol}</td>
                        <td>${agg.type}</td>
                        <td>${agg.totalPremium.toFixed(2)}</td>
                        <td>${agg.marketCap.toFixed(2)}</td>
                        <td>${ratio.toFixed(4)}</td>
                    `;
                    resultBody.appendChild(row);
                    sendDiscordAlert(agg);
                }
            });
        }

        function sendDiscordAlert(agg) {
            const maxRowsPerMessage = 20;
            const rows = agg.rows;
            const chunks = [];
            for (let i = 0; i < rows.length; i += maxRowsPerMessage) {
                chunks.push(rows.slice(i, i + maxRowsPerMessage));
            }

            const tableHeader = '| Date | Time | Symbol | Side | Strike | Type | Expiry | Bid | Ask | Spot |\n' +
                               '|------|------|--------|------|--------|------|--------|-----|-----|------|\n';
            const webhookUrl = 'https://discord.com/api/webhooks/YOUR_WEBHOOK_ID/YOUR_WEBHOOK_TOKEN';

            chunks.forEach((chunk, index) => {
                let message = 'New Alerts\n```md\n' + tableHeader;
                chunk.forEach(row => {
                    message += `| ${row.date} | ${row.time} | ${row.symbol} | ${row.side} | ${row.strike} | ${row.type} | ${row.expiry} | ${row.bid} | ${row.ask} | ${row.spot} |\n`;
                });
                message += '```';
                if (message.length > 2000) {
                    console.warn(`Message for ${agg.symbol} (${agg.type}) Part ${index + 1} exceeds 2000 characters and will not be sent.`);
                    return;
                }
                fetch(webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: message })
                })
                .then(response => {
                    if (response.ok) {
                        console.log(`Sent Discord alert for ${agg.symbol} (${agg.type}) Part ${index + 1}`);
                    } else {
                        console.error(`Failed to send Discord alert for ${agg.symbol} (${agg.type}) Part ${index + 1}`);
                    }
                })
                .catch(error => console.error('Error sending Discord alert:', error));
            });
        }

        function processData() {
            processFile(fileInput.files[0]);
        }
    </script>
</body>
</html>